## lists

Lists are mutable, unlike strings.

`examples = ['a',2.0,['b','c']]`  --  format  
`examples[1]` returns `'2.0'`  --  item by index  
`examples[-0]` returns `'a'`  --  item by negative index (right to left)  
`'a' in examples` returns `True` or `False`  --  Check if a list contains a value using _in_  
`examples.index('a')`  --  returns `0`  -- Find the _index_ of an item  
`examples.pop()`   --  returns `['b','c']`  **mutates list**  
`examples.pop(0)`   --  returns  `'a'`  **mutates list**  
`for example in examples: print example`  --   _traverses_ the list  
`for items in []` produces neither results nor errors 
`['a','b'] + ['a','b']` returns `['a','b','a','b']`  --  concatenate lists  
`['a','b'] * 3` returns `['a','b','a','b','a','b']`  --  repeat lists  
`e2 = ['a', 'b', 'c', 'd', 'e', 'f']`  _using a longer example for slicing..._  
`e2[1:3]` returns `['b','c']`  --  slice is inclusive of _start_, but not _end_  
`e2[0:]` returns e2, and `e2[0]` returns `'a'`  
`e2[:6]` returns e2, yet `e2[6]` returns an _IndexError_  **interesting** result  
`e2[1:1] = ['alpha','beta']` makes e2 `['a', 'alpha', 'beta', 'b', 'c', 'd', 'e', 'f']`  -- **mutates list**  
`examples.append('d')` makes examples `['a',2.0,['b','c'], 'd']`  -- append **mutates list**  
`another = example` means `another is example` is `True` -- **interesting** namespace result  
`another = example[:]` creates a copy and `another is example` is `False`  -- copy lists  
`e3 = ['d','e']` third example  
`e2.extend(e3)` results in e2 `['a', 'b', 'c', 'd', 'e', 'f', 'd', 'e']` and e3 is _unmodified_   --  **interesting** result  
`e2.sort()` returns void, e2 is now `['a', 'b', 'c', 'd', 'd', 'e', 'e', 'f']`  -- **interesting** result 
`e2.remove('e')` returns void, and removes _last item added_ with that value, e2 is now `['a', 'b', 'c', 'd', 'e', 'e', 'f']`  --  **interesting** result  
`scores = [99,88,72]` numerical example for built in functions  
`len(e3)`, `max(scores)`, `sum(scores)`, `min(e3)`  -- built in functions, `sum()` requires numerical values  

## Dictionaries

Dictionaries are key/value maps.

Dictionaries can be defined using `dict()` or using `{}` notation:

    empty_one = dict()
    empty_two = {}
    not_empty = {'key': 'value'}

Dictionaries are not ordered. To return a value, reference the key. Referencing a key that does not exists returns a KeyError, which can be easily avoided using `in`.

To see if a value exists in a dictionary without knowing the key, produce a list of the values using `not_empty.values()` and then `in`. Note that `in` is a linear search for lists, and therefore expensive, whereas `in` for dictionaries uses a hash table. 

> ! Compare dictionaries to collections and determine how tuples are relevant to data structure choices and search effectiveness / efficiency. !

`get(_key_, _default_)` gives the ability to return the value associated with a key _or return a default_. Note that the method does not create a new key and set that default, it only returns the default if no key is found.



## Sources used to compile this cheat sheet

* [Python Documentation 2.7](https://docs.python.org/2/) and [3.5](https://docs.python.org/3.5/)
* [Python for Informatics](http://www.pythonlearn.com/html-270/index.html)


